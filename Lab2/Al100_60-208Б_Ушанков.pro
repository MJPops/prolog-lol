/*				Хитрый шпион
	В некоторой далекой стране рыцари всегда говорили только правду и никогда не лгали, а
лжецы всегда только лгали и никогда не говорили правды. Однажды все население страны пришло в
необычайное волнение: стало известно, что в страну проник шпион из другой страны.
	Он был арестован вместе с двумя коренными жителями, один из которых был рыцарем, а другой
лжецом. Все трое предстали перед судом. Суд знал, что один из обвиняемых рыцарь, другой лжец,
третий шпион (который иногда лжет, а иногда говорит правду), но кто есть кто, суду не было известно.
	Обозначим подсудимых латинскими буквами А, В и С.
Сначала А заявил: — Я не шпион.
После чего В сказал: — Я шпион.
Тогда подсудимого С спросили: — В действительно шпион?
	В действительности шпионом был С. Будучи шпионом, он мог по своему усмотрению либо лгать, либо
говорить правду. На суде он всячески хитрил и изворачивался, отвечая так, чтобы его невозможно было
изобличить как шпиона.
Что ответил С на вопрос судьи?									*/

DOMAINS
    подсудимый = подсудимый(обозначение_подсудимого, тип_подсудимого);
        подсудимый(обозначение_подсудимого, тип_подсудимого, ответ_с)

    обозначение_подсудимого = symbol
    тип_подсудимого = symbol
    ответ_с = да; нет

    подсудимые = подсудимый*
    ответы = ответ_с*
PREDICATES
% Вспомогательные предикаты для работы со списками
    nondeterm входит_в(подсудимый, подсудимые)

% Возможные значения домэинов из задачи
    nondeterm возможное_обозначение_подсудимого(обозначение_подсудимого)
    nondeterm возможный_тип_подсудимого(тип_подсудимого)
    nondeterm возможный_ответ_с(ответ_с)

    nondeterm высказывание(обозначение_подсудимого, подсудимые)
    nondeterm проверка_высказываний(обозначение_подсудимого, подсудимые)
ClAUSES
    входит_в(Name, [Name|_]). 
	входит_в(Name, [_|Хвост]) :- входит_в(Name, Хвост).

% Перечисление возможных значений домейнов из условия задачи
    возможное_обозначение_подсудимого(Обозначение) :-
		Обозначение = а; 
		Обозначение = б; 
		Обозначение = с
    .
    возможный_тип_подсудимого(Тип) :-
		Тип = рыцарь;
		Тип = лжец;
		Тип = шпион
    .
    возможный_ответ_с(Ответ) :-
		Ответ = да;
		Ответ = нет
    .

% "а" сказал, что он не шпион
    высказывание(а, Подсудимые) :-
        NOT(входит_в(подсудимый(а, шпион), Подсудимые))
    .
% "б" сказал, что он шпион
    высказывание(б, Подсудимые) :-
        входит_в(подсудимый(б, шпион), Подсудимые)
    .
% "с" может сказать:
    высказывание(с, Подсудимые) :-
        входит_в(подсудимый(б, шпион), подсудимые),
        входит_в(подсудимый(с, шпион, да), подсудимые);
        NOT(входит_в(подсудимый(б, шпион))),
        входит_в(подсудимые(с, шпион, нет), подсудимые)
    .

    проверка_высказываний(Обозначение, Подсудимые) :-
	% Рыцарь сказал правду
		входит_в(подсудимый(Обозначение, рыцарь), Подсудимые),
		высказывание(Обозначение, Подсудимые);
    		
	% Лжец - соврал
    	входит_в(подсудимый(Обозначение, лжец), Подсудимые),
        NOT(высказывание(Обозначение, Подсудимые));
    		
    	входит_в(подсудимый(Обозначение, шпион), Подсудимые).

% Постусловие. Если исходный список пустой, то возвращаем формирумый список как результат 
	решение_без_повторов([], Накопитель, СписокБезПовторов):-
		СписокБезПовторов = Накопитель.
% Если текущий элемент списка уже есть в формируемом списке (Накопитель) , то переходим к проверке
% остальных элементов     
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
		входит_в(ПервыйЭлемент, Накопитель), 
		решение_без_повторов(ОстальныеЭлементы, Накопитель, СписокБезПовторов).
% Если текущий элемент списка отсутствует в формируемом списке (Накопитель), то добавляем его
% в Накопитель и переходим к проверке остальных элементов      
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
		NOT(входит_в(ПервыйЭлемент, Накопитель)),
		решение_без_повторов(ОстальныеЭлементы, [ПервыйЭлемент|Накопитель], СписокБезПовторов).
GOAL