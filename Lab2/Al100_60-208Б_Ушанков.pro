/*				Хитрый шпион
	В некоторой далекой стране рыцари всегда говорили только правду и никогда не лгали, а
лжецы всегда только лгали и никогда не говорили правды. Однажды все население страны пришло в
необычайное волнение: стало известно, что в страну проник шпион из другой страны.
	Он был арестован вместе с двумя коренными жителями, один из которых был рыцарем, а другой
лжецом. Все трое предстали перед судом. Суд знал, что один из обвиняемых рыцарь, другой лжец,
третий шпион (который иногда лжет, а иногда говорит правду), но кто есть кто, суду не было известно.
	Обозначим подсудимых латинскими буквами А, В и С.
Сначала А заявил: — Я не шпион.
После чего В сказал: — Я шпион.
Тогда подсудимого С спросили: — В действительно шпион?
	В действительности шпионом был С. Будучи шпионом, он мог по своему усмотрению либо лгать, либо
говорить правду. На суде он всячески хитрил и изворачивался, отвечая так, чтобы его невозможно было
изобличить как шпиона.
Что ответил С на вопрос судьи?									*/

DOMAINS
% Такая структура нужна для того, чтобы соотнести определенный набор
% подсудимых с одним ответом
  	подсудимый_или_ответ_с = подсудимый(обозначение_персонажа, тип_персонажа); вычказывание_с(ответ_с)

% "Рыцарь", "Лжец", "Шпион"
% Не перечисление, так как предполагаем добавление новых типов
	тип_персонажа = symbol
% Обозначения рыцарей, а именно: "А", "В", "С"
% symbol, т.к. есть вероятность введения новых персонажей
	обозначение_персонажа = symbol
% Перечисление, т.к. ответ может быть только "да" или "нет"
	ответ_с = да; нет

  	все_ответы = ответ_с*
	типы_персонажей = тип_персонажа*

% Предполагается, что ответ будет один
% т.е. мы будем иметь определенный набор подсудимых и один ответ в рамках этого набора
  	комбинация_подсудимых_и_ответа_с = подсудимый_или_ответ_с*
% Представляет из себя список, состоящий из наборов подсудимых и ответа "С"
  	множество_комбинаций_подсудимых_и_ответа_с = комбинация_подсудимых_и_ответа_с*
PREDICATES
% Вспомогательные предикаты для работы со списками
  	nondeterm входит_в(подсудимый_или_ответ_с, комбинация_подсудимых_и_ответа_с)
  	nondeterm входит_в(комбинация_подсудимых_и_ответа_с, множество_комбинаций_подсудимых_и_ответа_с)
  	nondeterm входит_в(ответ_с, все_ответы)
  	nondeterm входит_в(тип_персонажа, типы_персонажей)
	nondeterm без_повторов(типы_персонажей)
	nondeterm без_повторов(множество_комбинаций_подсудимых_и_ответа_с)
  	nondeterm решение_без_повторов(все_ответы, все_ответы, все_ответы)

% Факты из условия задачи
  	nondeterm возможный_тип_подозреваемого(тип_персонажа)
  	nondeterm возможное_обозначение_подозреваемого(обозначение_персонажа)
  	nondeterm возможный_ответ(ответ_с)
  	nondeterm сказал(обозначение_персонажа, комбинация_подсудимых_и_ответа_с)
  
  	nondeterm проверка_высказывания(обозначение_персонажа, комбинация_подсудимых_и_ответа_с)
  	nondeterm проверка_высказываний(комбинация_подсудимых_и_ответа_с)

% Задаются правила для подсудимых и ответа
  	nondeterm настройка_значений(комбинация_подсудимых_и_ответа_с)
  	nondeterm проверка_всех_высказываний(комбинация_подсудимых_и_ответа_с)
  
  	nondeterm поиск_всех_ответов(ответ_с)
  	nondeterm проверка_ответа_с(множество_комбинаций_подсудимых_и_ответа_с, ответ_с)
  
  	nondeterm поиск_решений_без_повторов(все_ответы)
ClAUSES
	входит_в(Name, [Name|_]). 
	входит_в(Name, [_|Хвост]) :-
		входит_в(Name, Хвост).

% Это правило говорит нам о том, что в пустом списке нет повтором
	без_повторов([]).
% Это правило отделяет первый элемент и проверяет, входит ли он в хвост.
% Если нет, то поиск продолжается рекурсивно для остальных элементов (Хвост)
% Если есть, то неудача
% Рекурсия прекратится, когда будет вызвано правило "без_повторов" для пустого списка
	без_повторов([Name|Хвост]) :-
		NOT(входит_в(Name, Хвост)),
		без_повторов(Хвост).

% Постусловие. Если исходный список пустой, то возвращаем формирумый список как результат 
	решение_без_повторов([], Накопитель, СписокБезПовторов) :-
		СписокБезПовторов = Накопитель.
% Если текущий элемент списка уже есть в формируемом списке (Накопитель) , то переходим к проверке
% остальных элементов     
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов) :-
		входит_в(ПервыйЭлемент, Накопитель), 
		решение_без_повторов(ОстальныеЭлементы, Накопитель, СписокБезПовторов).
% Если текущий элемент списка отсутствует в формируемом списке (Накопитель), то добавляем его
% в Накопитель и переходим к проверке остальных элементов      
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов) :-
		not(входит_в(ПервыйЭлемент, Накопитель)),
		решение_без_повторов(ОстальныеЭлементы, [ПервыйЭлемент|Накопитель], СписокБезПовторов).

  	возможный_тип_подозреваемого(ТипПодозреваемого) :-
		ТипПодозреваемого = рыцарь;
		ТипПодозреваемого = лжец;
		ТипПодозреваемого = шпион.
  	возможное_обозначение_подозреваемого(ИмяПодозреваемого) :-
		ИмяПодозреваемого = а; 
		ИмяПодозреваемого = б; 
		ИмяПодозреваемого = с.
  	возможный_ответ(ОтветС) :-
		ОтветС = да;
		ОтветС = нет.

% "а" сказал, что он не шпион
	сказал(а, ПодсудимыеИОтвет):-
		not(входит_в(подсудимый(а, шпион), ПодсудимыеИОтвет)).
% "б" сказал, что он шпион
	сказал(б, ПодсудимыеИОтвет):-
		входит_в(подсудимый(б, шпион), ПодсудимыеИОтвет).
% "с" может сказать:
	сказал(с, ПодсудимыеИОтвет):-
	% Запишем в комбинацию ответ "С"
		входит_в(вычказывание_с(да), ПодсудимыеИОтвет),
	% "да", тогда "б" - шпион
		входит_в(подсудимый(б, шпион), ПодсудимыеИОтвет);
	% Запишем в комбинацию ответ "С"
		входит_в(вычказывание_с(нет), ПодсудимыеИОтвет),
	% "нет", тогда "б" - не шпион
		not(входит_в(подсудимый(б, шпион), ПодсудимыеИОтвет)).
    
  	проверка_высказывания(ИмяПодозреваемого, ПодсудимыеИОтвет) :-
	% Если "Рыцарь" сказал правду
		входит_в(подсудимый(ИмяПодозреваемого, рыцарь), ПодсудимыеИОтвет),
		сказал(ИмяПодозреваемого, ПодсудимыеИОтвет);
    		
	% Если "Лжец" - соврал
    	входит_в(подсудимый(ИмяПодозреваемого, лжец), ПодсудимыеИОтвет), not(сказал(ИмяПодозреваемого, ПодсудимыеИОтвет));

	% Про "Шпион" ничего не значем, кроме того, что он есть	
    	входит_в(подсудимый(ИмяПодозреваемого, шпион), ПодсудимыеИОтвет).

	% Исходя из этой проверки получим:
	% Пусть "С" сказал "да", тогда "А" не соврал - значит он "рыцарь", но и "Б" не соврал - значит он тоже "рыцарь",
	% чего не может быть
	% Если суд предположит, что "С" "лжец", тогда "Б" не шпион, значит он "лжец", но тогда и А "лжец"
	% чего не может быть
	% Таким образом эта проверка заключит, что вариант ответа "да" не подходит, т.к. вызывает расхождения
	% с условиями задачи
    
  	проверка_высказываний(ПодсудимыеИОтвет):-
		проверка_высказывания(а, ПодсудимыеИОтвет),
		проверка_высказывания(б, ПодсудимыеИОтвет),
		проверка_высказывания(с, ПодсудимыеИОтвет).

% Генерация множества подсудимых с ответом
  	настройка_значений
  	([
		подсудимый(а, ТипА), 
		подсудимый(б, ТипБ), 
		подсудимый(с, ТипС), 
		вычказывание_с(ОтветС)
  	]):-
	% Записываем типы_персонажей
		возможный_тип_подозреваемого(ТипА), возможный_тип_подозреваемого(ТипБ), возможный_тип_подозреваемого(ТипС),
	% Типы не могут повторяться
		без_повторов([ТипА, ТипБ, ТипС]),
	% Либо "да" либо "нет"
		возможный_ответ(ОтветС).

  	проверка_всех_высказываний(ПодсудимыеИОтвет) :-
		настройка_значений(ПодсудимыеИОтвет),
		проверка_высказываний(ПодсудимыеИОтвет).
    
% Проверка всех ответов
  	поиск_всех_ответов(ОтветС) :-
		findall(ПодсудимыеИОтвет, проверка_всех_высказываний(ПодсудимыеИОтвет), ВсеКомбинацииПодсудимыхИОтветов),
		проверка_ответа_с(ВсеКомбинацииПодсудимыхИОтветов, ОтветС).
    
% "С" ответил так, чтобы запутать следствие,
% надо найти две разные комбинации подсудимых с одинаковым ответом "С"
  	проверка_ответа_с(ВсеКомбинацииПодсудимыхИОтветов, ОтветС) :-
    		входит_в(ПодсудимыеИОтвет_1, ВсеКомбинацииПодсудимыхИОтветов),
    		входит_в(ПодсудимыеИОтвет_2, ВсеКомбинацииПодсудимыхИОтветов),

    		без_повторов([ПодсудимыеИОтвет_1, ПодсудимыеИОтвет_2]),

    		входит_в(вычказывание_с(ОтветС), ПодсудимыеИОтвет_1),
    		входит_в(вычказывание_с(ОтветС), ПодсудимыеИОтвет_2).
  
  	поиск_решений_без_повторов(СписокБезПовторов):-
    		findall(Решение, поиск_всех_ответов(Решение), Решения),
    		решение_без_повторов(Решения, [], СписокБезПовторов).
GOAL
  	поиск_решений_без_повторов(С_ответил).