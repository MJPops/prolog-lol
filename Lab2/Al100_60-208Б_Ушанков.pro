/*				Хитрый шпион
	В некоторой далекой стране рыцари всегда говорили только правду и никогда не лгали, а
лжецы всегда только лгали и никогда не говорили правды. Однажды все население страны пришло в
необычайное волнение: стало известно, что в страну проник шпион из другой страны.
	Он был арестован вместе с двумя коренными жителями, один из которых был рыцарем, а другой
лжецом. Все трое предстали перед судом. Суд знал, что один из обвиняемых рыцарь, другой лжец,
третий шпион (который иногда лжет, а иногда говорит правду), но кто есть кто, суду не было известно.
	Обозначим подсудимых латинскими буквами А, В и С.
Сначала А заявил: — Я не шпион.
После чего В сказал: — Я шпион.
Тогда подсудимого С спросили: — В действительно шпион?
	В действительности шпионом был С. Будучи шпионом, он мог по своему усмотрению либо лгать, либо
говорить правду. На суде он всячески хитрил и изворачивался, отвечая так, чтобы его невозможно было
изобличить как шпиона.
Что ответил С на вопрос судьи?									*/

DOMAINS
% Перечисление, т.к. введение новых типов не предполагается
% Перебраны все 3 варианта: всегда врет, всегда правдив и может как врать так и говорить правду
	тип_персонажа = рыцарь; лжец; шпион
% Обозначения рыцарей, а именно: "А", "В", "С"
% symbol, т.к. есть вероятность введения новых персонажей
	обозначение_персонажа = symbol
% Перечисление, т.к. ответ может быть только "да" или "нет"
	ответ_с = да; нет

% Такая сложная структура нужна для того, чтобы соотнести определенный набор
% подсудимых с одним ответом
  	подсудимый_или_ответ_с = подсудимый(обозначение_персонажа, тип_персонажа); с_сказал(ответ_с)

  	все_ответы = ответ_с*

% Предполагается, что ответ будет один
% т.е. мы будем иметь определенный набор подсудимых и один ответ в рамках этого набора
  	комбинация_подсудимых_и_ответа_с = подсудимый_или_ответ_с*
% Представляет из себя список, состоящий из наборов подсудимых и ответа "С"
  	множество_комбинаций_подсудимых_и_ответа_с = комбинация_подсудимых_и_ответа_с*
PREDICATES
% Вспомогательные предикаты для работы со списками
  	nondeterm входит_в(подсудимый_или_ответ_с, комбинация_подсудимых_и_ответа_с)
  	nondeterm входит_в(комбинация_подсудимых_и_ответа_с, множество_комбинаций_подсудимых_и_ответа_с)
  	nondeterm входит_в(ответ_с, все_ответы)
  	nondeterm решение_без_повторов(все_ответы, все_ответы, все_ответы)

% Факты из условия задачи
  	nondeterm возможный_тип_подозреваемого(тип_персонажа)
  	nondeterm возможное_обозначение_подозреваемого(обозначение_персонажа)
  	nondeterm возможный_ответ(ответ_с)
  	nondeterm сказал(обозначение_персонажа, комбинация_подсудимых_и_ответа_с)
  
  	nondeterm проверка_высказывания(обозначение_персонажа, комбинация_подсудимых_и_ответа_с)
  	nondeterm проверка_высказываний(комбинация_подсудимых_и_ответа_с)

% Задаются правила для подсудимых и ответа
  	nondeterm настройка_значений(комбинация_подсудимых_и_ответа_с)
  	nondeterm проверка_гипотезы(комбинация_подсудимых_и_ответа_с)
  
  	nondeterm поиск_всех_ответов(ответ_с)
  	nondeterm проверка_ответа_с(множество_комбинаций_подсудимых_и_ответа_с, ответ_с)
  
  	nondeterm поиск_уникальных_решений(все_ответы)
ClAUSES
	входит_в(Name, [Name|_]). 
	входит_в(Name, [_|Хвост]) :- 
		входит_в(Name, Хвост).

  	возможный_тип_подозреваемого(Тип) :-
		Тип = рыцарь;
		Тип = лжец;
		Тип = шпион.
  	возможное_обозначение_подозреваемого(Имя) :-
		Имя = а; 
		Имя = б; 
		Имя = с.
  	возможный_ответ(Ответ) :-
		Ответ = да;
		Ответ = нет.

% "а" сказал, что он не шпион
	сказал(а, ПодсудимыеИОтвет):-
		NOT(входит_в(подсудимый(а, шпион), ПодсудимыеИОтвет)).
% "б" сказал, что он шпион
	сказал(б, ПодсудимыеИОтвет):-
		входит_в(подсудимый(б, шпион), ПодсудимыеИОтвет).
% "с" может сказать:
	сказал(с, ПодсудимыеИОтвет):-
	% Запишем в комбинацию ответ "С"
		входит_в(с_сказал(да), ПодсудимыеИОтвет),
	% "да", тогда "б" - шпион
		входит_в(подсудимый(б, шпион), ПодсудимыеИОтвет);
	% Запишем в комбинацию ответ "С"
		входит_в(с_сказал(нет), ПодсудимыеИОтвет),
	% "нет", тогда "б" - не шпион
		NOT(входит_в(подсудимый(б, шпион), ПодсудимыеИОтвет)).
    
  	проверка_высказывания(Имя, ПодсудимыеИОтвет) :-
	% Рыцарь сказал правду
		входит_в(подсудимый(Имя, рыцарь), ПодсудимыеИОтвет),
		сказал(Имя, ПодсудимыеИОтвет);
    		
	% Лжец - соврал
    	входит_в(подсудимый(Имя, лжец), ПодсудимыеИОтвет), NOT(сказал(Имя, ПодсудимыеИОтвет));
    		
    	входит_в(подсудимый(Имя, шпион), ПодсудимыеИОтвет).
    
  	проверка_высказываний(ПодсудимыеИОтвет):-
		проверка_высказывания(а, ПодсудимыеИОтвет),
		проверка_высказывания(б, ПодсудимыеИОтвет),
		проверка_высказывания(с, ПодсудимыеИОтвет).

% Генерация множество_комбинаций_подсудимых_и_ответа_с
  	настройка_значений
  	([
		подсудимый(а, ТипА), 
		подсудимый(б, ТипБ), 
		подсудимый(с, ТипС), 
		с_сказал(Ответ)
  	]):-
		возможный_тип_подозреваемого(ТипА), возможный_тип_подозреваемого(ТипБ), возможный_тип_подозреваемого(ТипС),
		NOT(ТипА=ТипБ), NOT(ТипА=ТипС), NOT(ТипБ=ТипС),
		возможный_ответ(Ответ).

  	проверка_гипотезы(ПодсудимыеИОтвет) :-
		настройка_значений(ПодсудимыеИОтвет),
		проверка_высказываний(ПодсудимыеИОтвет).
    
% Проверка множество_комбинаций_подсудимых_и_ответа_с
  	поиск_всех_ответов(ОтветС) :-
		findall(ПодсудимыеИОтвет, проверка_гипотезы(ПодсудимыеИОтвет), ВсеКомбинацииПодсудимыхИОтветов),
		проверка_ответа_с(ВсеКомбинацииПодсудимыхИОтветов, ОтветС).
    
% "С" ответил так, чтобы запутать следствие,
% надо найти две разные множество_комбинаций_подсудимых_и_ответа_с с одинаковым ответом "С"
  	проверка_ответа_с(ВсеКомбинацииПодсудимыхИОтветов, ОтветС):-
    		входит_в(ПодсудимыеИОтвет_2, ВсеКомбинацииПодсудимыхИОтветов),
    		NOT(ПодсудимыеИОтвет_1 = ПодсудимыеИОтвет_2),

    		входит_в(с_сказал(ОтветС), ПодсудимыеИОтвет_1),
    		входит_в(с_сказал(ОтветС), ПодсудимыеИОтвет_2).
  
  	поиск_уникальных_решений(УникальныеРешения):-
    		findall(Решение, поиск_всех_ответов(Решение), Решения),
    		решение_без_повторов(Решения, [], УникальныеРешения).

% Постусловие. Если исходный список пустой, то возвращаем формирумый список как результат 
	решение_без_повторов([], Накопитель, СписокБезПовторов):-
		СписокБезПовторов = Накопитель.
% Если текущий элемент списка уже есть в формируемом списке (Накопитель) , то переходим к проверке
% остальных элементов     
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
		входит_в(ПервыйЭлемент, Накопитель), 
		решение_без_повторов(ОстальныеЭлементы, Накопитель, СписокБезПовторов).
% Если текущий элемент списка отсутствует в формируемом списке (Накопитель), то добавляем его
% в Накопитель и переходим к проверке остальных элементов      
	решение_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
		NOT(входит_в(ПервыйЭлемент, Накопитель)),
		решение_без_повторов(ОстальныеЭлементы, [ПервыйЭлемент|Накопитель], СписокБезПовторов).
GOAL
  	поиск_уникальных_решений(С_ответил).